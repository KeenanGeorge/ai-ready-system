name: Go Coverage & Tests
on:
  pull_request:
  push:
    branches: [ main ]

env:
  COVERAGE_THRESHOLD: 75  # Temporarily set to 60% to match current coverage
  MAX_TEST_RETRIES: 3

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y bc

      - name: Cache Go modules
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-go-

      - name: Install gotestsum (JUnit)
        run: go install gotest.tools/gotestsum@latest

      # Enhanced test execution with retry logic
      - name: Run unit tests with retry logic
        id: test-execution
        run: |
          mkdir -p reports
          echo "üß™ Starting test execution with retry logic..."
          
          for i in $(seq 1 ${{ env.MAX_TEST_RETRIES }}); do
            echo "üìã Attempt $i of ${{ env.MAX_TEST_RETRIES }}..."
            
            if ~/go/bin/gotestsum --junitfile reports/unit-tests.xml -- -coverprofile=coverage.out -covermode=atomic ./...; then
              echo "‚úÖ Tests passed on attempt $i"
              echo "attempt_number=$i" >> $GITHUB_OUTPUT
              break
            fi
            
            if [ $i -eq ${{ env.MAX_TEST_RETRIES }} ]; then
              echo "‚ùå All ${{ env.MAX_TEST_RETRIES }} test attempts failed"
              exit 1
            fi
            
            echo "‚ö†Ô∏è Attempt $i failed, retrying in 5 seconds..."
            sleep 5
          done

      # Fixed coverage threshold enforcement with robust parsing
      - name: Enforce coverage threshold
        id: coverage-check
        run: |
          echo "üìä Checking coverage threshold..."
          
          # Debug: Show coverage file contents
          echo "Coverage file contents:"
          cat coverage.out
          
          # Method 1: Try standard go tool cover parsing
          echo "üîç Method 1: Standard go tool cover parsing..."
          COVERAGE=$(go tool cover -func=coverage.out 2>/dev/null | grep -E '^total:' | awk '{print $3}' | sed 's/%//')
          
          # Method 2: Fallback to manual parsing if Method 1 fails
          if [ -z "$COVERAGE" ] || [ "$COVERAGE" = "0" ]; then
            echo "‚ö†Ô∏è Method 1 failed, trying Method 2: Manual coverage calculation..."
            
            # Parse coverage manually from the file
            TOTAL_LINES=$(wc -l < coverage.out)
            if [ $TOTAL_LINES -gt 1 ]; then
              # Skip the first line (mode: atomic)
              COVERED_LINES=$(tail -n +2 coverage.out | awk -F' ' '{sum += $4} END {print sum}')
              TOTAL_CODE_LINES=$(tail -n +2 coverage.out | awk -F' ' '{sum += $3} END {print sum}')
              
              echo "Debug: Covered lines = $COVERED_LINES, Total code lines = $TOTAL_CODE_LINES"
              
              if [ -n "$COVERED_LINES" ] && [ -n "$TOTAL_CODE_LINES" ] && [ "$TOTAL_CODE_LINES" -gt 0 ]; then
                COVERAGE=$(echo "scale=1; $COVERED_LINES * 100 / $TOTAL_CODE_LINES" | bc)
                echo "üìä Manual calculation: $COVERED_LINES covered out of $TOTAL_CODE_LINES lines = $COVERAGE%"
              else
                echo "‚ö†Ô∏è Manual calculation failed, trying Method 3: Direct parsing..."
                
                # Method 3: Direct parsing of the specific format
                # Format: example.com/go-linear-testmo-demo/main.go:8.60,10.2 1 8
                # Extract the last two numbers: covered lines and total lines
                COVERED_LINES=$(tail -n +2 coverage.out | awk '{print $4}' | paste -sd+ | bc)
                TOTAL_CODE_LINES=$(tail -n +2 coverage.out | awk '{print $3}' | paste -sd+ | bc)
                
                echo "Debug Method 3: Covered lines = $COVERED_LINES, Total code lines = $TOTAL_CODE_LINES"
                
                if [ -n "$COVERED_LINES" ] && [ -n "$TOTAL_CODE_LINES" ] && [ "$TOTAL_CODE_LINES" -gt 0 ]; then
                  COVERAGE=$(echo "scale=1; $COVERED_LINES * 100 / $TOTAL_CODE_LINES" | bc)
                  echo "üìä Method 3 calculation: $COVERED_LINES covered out of $TOTAL_CODE_LINES lines = $COVERAGE%"
                else
                  echo "‚ö†Ô∏è All methods failed, using fallback..."
                  COVERAGE=25  # Conservative estimate
                fi
              fi
            else
              echo "‚ö†Ô∏è Coverage file too small, using fallback..."
              COVERAGE=0
            fi
          fi
          
          echo "üìä Final coverage result: ${COVERAGE}%"
          echo "üéØ Threshold: ${{ env.COVERAGE_THRESHOLD }}%"
          
          # Check if coverage meets threshold
          if (( $(echo "$COVERAGE < ${{ env.COVERAGE_THRESHOLD }}" | bc -l) )); then
            echo "‚ùå Coverage ${COVERAGE}% below ${{ env.COVERAGE_THRESHOLD }}% threshold"
            echo "coverage_status=failed" >> $GITHUB_OUTPUT
            echo "coverage_percentage=$COVERAGE" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "‚úÖ Coverage ${COVERAGE}% meets ${{ env.COVERAGE_THRESHOLD }}% threshold"
            echo "coverage_status=passed" >> $GITHUB_OUTPUT
            echo "coverage_percentage=$COVERAGE" >> $GITHUB_OUTPUT
          fi

      # Generate comprehensive coverage reports
      - name: Generate coverage reports
        run: |
          echo "üìà Generating detailed coverage reports..."
          
          # HTML coverage report
          go tool cover -html=coverage.out -o reports/coverage.html
          
          # Text coverage report
          go tool cover -func=coverage.out > reports/coverage.txt
          
          # Show coverage summary
          echo "üìä Coverage Summary:"
          if go tool cover -func=coverage.out | grep total:; then
            echo "‚úÖ Standard coverage report generated"
          else
            echo "‚ö†Ô∏è Standard coverage report failed, showing manual analysis:"
            echo "Coverage file analysis:"
            cat coverage.out
          fi
          
          # Count test files and show test structure
          echo "üß™ Test Files Found:"
          find . -name "*_test.go" -exec basename {} \;
          echo "Total test files: $(find . -name "*_test.go" | wc -l)"

      # Security scanning
      - name: Install security tools
        run: |
          echo "üîí Installing security scanning tools..."
          go install github.com/sonatype-nexus-community/nancy@latest
          go install github.com/google/go-licenses@latest

      - name: Security scan dependencies
        id: security-scan
        run: |
          echo "üîç Scanning dependencies for vulnerabilities..."
          
          # Scan for known CVEs
          if go list -json -deps ./... | nancy sleuth; then
            echo "‚úÖ No critical vulnerabilities found"
            echo "security_status=passed" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Critical vulnerabilities detected"
            echo "security_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Check license compliance
        id: license-check
        run: |
          echo "üìú Checking license compliance..."
          
          if go-licenses check ./...; then
            echo "‚úÖ License compliance check passed"
            echo "license_status=passed" >> $GITHUB_OUTPUT
          else
            echo "‚ùå License compliance check failed"
            echo "license_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Setup Node (for Testmo CLI)
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Testmo CLI
        run: npm i -g @testmo/testmo-cli

      # FIXED: Replace broken Testmo CLI commands with working workflow pattern
      - name: Get commit info
        id: commit
        run: |
          echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          echo "branch=$(git rev-parse --abbrev-ref HEAD)" >> $GITHUB_OUTPUT
          echo "message=$(git log -1 --pretty=format:'%s')" >> $GITHUB_OUTPUT

      - name: Create Testmo run
        id: testmo
        env:
          TESTMO_TOKEN: ${{ secrets.TESTMO_TOKEN }}
        run: |
          RUN_ID=$(testmo automation:run:create \
            --instance ${{ secrets.TESTMO_INSTANCE }} \
            --name "CI: ${{ steps.commit.outputs.branch }} - ${{ steps.commit.outputs.sha }}" \
            --source "go-ci")
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT

      - name: Submit test results to Testmo
        env:
          TESTMO_TOKEN: ${{ secrets.TESTMO_TOKEN }}
        run: |
          testmo automation:run:submit \
            --instance ${{ secrets.TESTMO_INSTANCE }} \
            --name "Test Results: ${{ steps.commit.outputs.branch }}" \
            --source "go-ci" \
            --results reports/unit-tests.xml

      - name: Complete Testmo run
        env:
          TESTMO_TOKEN: ${{ secrets.TESTMO_TOKEN }}
        run: |
          testmo automation:run:complete \
            --instance ${{ secrets.TESTMO_INSTANCE }} \
            --run-id "${{ steps.testmo.outputs.run_id }}"

      # Enhanced PR comments with quality metrics
      - name: Comment on PR with quality metrics
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const testmoUrl = `https://app.testmo.com/automation/runs/${{ steps.testmo.outputs.run_id }}`;
            const testAttempts = `${{ steps.test-execution.outputs.attempt_number }}`;
            const coverageStatus = `${{ steps.coverage-check.outputs.coverage_status }}`;
            const coveragePercentage = `${{ steps.coverage-check.outputs.coverage_percentage }}`;
            const securityStatus = `${{ steps.security-scan.outputs.security_status }}`;
            const licenseStatus = `${{ steps.license-check.outputs.license_status }}`;
            
            const comment = `## üß™ CI Quality Report

            ### ‚úÖ Test Execution
            - **Status**: Tests passed on attempt ${testAttempts || 1}
            - **Reliability**: Retry logic enabled (max ${{ env.MAX_TEST_RETRIES }} attempts)

            ### üìä Coverage Analysis
            - **Status**: ${coverageStatus === 'passed' ? '‚úÖ PASSED' : '‚ùå FAILED'}
            - **Coverage**: ${coveragePercentage}% (threshold: ${{ env.COVERAGE_THRESHOLD }}%)
            - **Quality Gate**: ${coverageStatus === 'passed' ? 'Meets requirements' : 'Below threshold'}

            ### üîí Security & Compliance
            - **Vulnerability Scan**: ${securityStatus === 'passed' ? '‚úÖ PASSED' : '‚ùå FAILED'}
            - **License Compliance**: ${licenseStatus === 'passed' ? '‚úÖ PASSED' : '‚ùå FAILED'}

            ### üìÅ Artifacts Available
            - JUnit XML report
            - Coverage HTML report
            - Coverage text summary
            - Security scan results

            ### üéØ Production Ready
            ${coverageStatus === 'passed' && securityStatus === 'passed' && licenseStatus === 'passed' 
              ? '‚úÖ **All quality gates passed - Ready for production!**' 
              : '‚ùå **Quality gates failed - Review required before production**'}

            ### üîó Testmo Integration
            - **Testmo Run**: [View Results](${testmoUrl})
            - **Run ID**: \`${{ steps.testmo.outputs.run_id }}\`

            ---
            *Generated by enhanced CI pipeline (SMA-17)*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ github.run_id }}
          path: |
            reports/
            coverage.out
          retention-days: 30
